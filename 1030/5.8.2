1. PUSH와 POP 명령어만 사용하여 EAX와 EBX 레지스터의 값을 서로 교환하는(swap) 문장들을 작성하세요. (64비트 모드에서는 RAX와 RBX)
[
push eax
push ebx
pop eax
pop ebx
; 설명: 스택은 LIFO(Last-In First-Out) 구조이므로, 나중에 넣은 EBX 값이 먼저 나와서 EAX로 들어가고, 처음에 넣은 EAX 값이 나중에 나와서 EBX로 들어갑니다.
]

2. 서브루틴이 스택에 현재 저장된 복귀 주소(return address)보다 메모리 상에서 3바이트 더 높은 주소로 복귀하기를 원한다고 가정합시다. 이 작업을 수행하기 위해 서브루틴의 RET 명령어 바로 앞에 삽입할 명령어 시퀀스를 작성하세요.
[
pop eax            ; 복귀 주소를 꺼냄
add eax, 3         ; 주소에 3을 더함
push eax           ; 수정된 주소를 다시 스택에 넣음
; 또는 더 간단하게: add DWORD PTR [esp], 3
]

3. 고수준 언어의 함수들은 종종 스택의 복귀 주소 바로 아래에 지역 변수(local variables)를 선언합니다. 두 개의 정수 더블워드 변수를 위한 공간을 예약하기 위해 서브루틴 시작 부분에 넣을 수 있는 명령어를 작성하세요. 그 후, 두 지역 변수에 1000h와 2000h 값을 할당하세요.
[
push ebp
mov ebp, esp
sub esp, 8                 ; 2개의 DWORD(4바이트*2) 공간 예약
mov DWORD PTR [ebp-4], 1000h
mov DWORD PTR [ebp-8], 2000h
]

4. 인덱스 주소 지정을 사용하여 더블워드 배열의 한 요소를 동일한 배열의 바로 이전 위치(previous position)로 복사하는 문장들을 작성하세요.
[
; ESI가 현재 요소의 인덱스를 가리킨다고 가정
mov eax, array[esi]        ; 현재 요소 값을 레지스터로 복사
mov array[esi-4], eax      ; 이전 위치(DWORD이므로 -4)에 저장
]

5. 서브루틴의 복귀 주소를 표시(display)하는 문장들을 작성하세요. 스택에 가한 변경 사항이 서브루틴이 호출자에게 복귀하는 것을 방해하지 않도록 해야 합니다. (복귀 주소는 스택의 최상위에 있습니다.)
[
mov eax, [esp]             ; 복귀 주소를 EAX로 복사 (스택에서 제거하지 않음)
call WriteHex              ; Irvine 라이브러리를 사용하여 값 출력 (예시)
; 설명: POP을 사용하지 않고 [ESP]를 통해 값만 읽어오면 스택 포인터가 변경되지 않아 정상적으로 리턴할 수 있습니다.
]
