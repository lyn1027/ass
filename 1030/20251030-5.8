1. 어떤 명령어가 32비트 범용 레지스터 전체를 스택에 푸시(push)합니까? [PUSHAD]

2. 어떤 명령어가 32비트 EFLAGS 레지스터를 스택에 푸시합니까? [PUSHFD]

3. 어떤 명령어가 스택에서 값을 팝(pop)하여 EFLAGS 레지스터에 저장합니까? [POPFD]

4. 다른 어셈블러(NASM 등)는 PUSH 명령어 뒤에 여러 레지스터를 나열하는 것을 허용합니다. 이 방식이 MASM의 PUSHAD 명령어보다 나은 점은 무엇일까요?
[필요한 특정 레지스터만 선택적으로 저장할 수 있어, 모든 레지스터를 저장하는 것보다 메모리 공간을 절약하고 실행 속도를 높일 수 있습니다.]

5. PUSH 명령어가 없다고 가정할 때, push eax와 동일한 동작을 수행하는 두 개의 다른 명령어 시퀀스를 작성하세요.
[sub esp, 4
mov [esp], eax]

6. RET 명령어는 스택의 최상위 값을 명령어 포인터(Instruction Pointer)로 팝(pop)합니다. [참]

7. 프로시저 정의에 NESTED 연산자를 사용하지 않으면 Microsoft 어셈블러에서 중첩된 프로시저 호출(Nested procedure calls)이 허용되지 않습니다. [거짓]

8. 보호 모드(Protected mode)에서 각 프로시저 호출은 최소 4바이트의 스택 공간을 사용합니다. [참]

9. 프로시저에 32비트 매개변수를 전달할 때 ESI와 EDI 레지스터는 사용할 수 없습니다. [거짓]

10. ArraySum 프로시저(5.2.5절)는 모든 더블워드(doubleword) 배열에 대한 포인터를 인자로 받을 수 있습니다. [참]

11. USES 연산자를 사용하면 프로시저 내에서 수정되는 모든 레지스터의 이름을 지정하여 자동으로 보존할 수 있습니다. [참]

12. USES 연산자는 PUSH 명령어만 생성하므로, POP 명령어는 직접 작성해야 합니다. [거짓]

13. USES 지시어의 레지스터 목록은 쉼표(comma)를 사용하여 레지스터 이름을 구분해야 합니다. [거짓]

14. 16비트 워드(word) 배열을 누적 계산할 수 있도록 ArraySum 프로시저를 수정하려면 어떤 구문을 변경해야 합니까?
[데이터를 더하는 명령어를 32비트 연산에서 16비트 연산으로 변경하고, 배열 포인터(ESI)의 증가량을 4에서 2로 변경해야 합니다.]

15. 다음 명령어가 실행된 후 EAX의 최종 값은 무엇입니까?
    push 5
    push 6
    pop eax
    pop eax
[5]

16. 다음 예제 코드가 실행될 때 사실인 것은 무엇입니까? (스택 오용 문제)
    1: main PROC
    2:   push 10
    3:   push 20
    4:   call Ex2Sub
    ...
    9: Ex2Sub PROC
    10:  pop eax
    11:  ret
[프로그램은 11번 줄에서 런타임 에러로 중단됩니다.] (설명: Ex2Sub 안에서 pop eax가 복귀 주소를 꺼내버려, ret 명령어가 스택에 남아있던 숫자 20을 주소로 착각하고 점프하려 하기 때문입니다.)

17. 다음 예제 코드가 실행될 때 사실인 것은 무엇입니까?
    ...
    mov eax, 30
    push eax
    push 40
    call Ex3Sub
    ...
    Ex3Sub PROC
      pusha
      mov eax, 80
      popa
      ret
[6번 줄에서 EAX는 30이 됩니다.]

18. 다음 예제 코드가 실행될 때 사실인 것은 무엇입니까?
    ...
    push offset Here
    jmp Ex4Sub
    Here:
      mov eax, 30
    ...
    Ex4Sub PROC
      ret
[6번 줄(Here 레이블 위치)에서 EAX는 30이 됩니다.]

19. 다음 예제 코드가 실행될 때 사실인 것은 무엇입니까?
    mov edx, 0
    mov eax, 40
    push eax
    call Ex5Sub
    ...
    Ex5Sub PROC
      pop eax  ; 복귀 주소를 eax에 저장
      pop edx  ; 40을 edx에 저장
      push eax ; 복귀 주소를 다시 스택에 넣음
      ret
[6번 줄에서 EDX는 40이 됩니다.]

20. 다음 코드가 실행된 후 배열(array)에 기록되는 값들은 무엇입니까?
    .data
    array DWORD 4 DUP(0)
    ...
    (main에서 proc_1 호출 -> proc_2 호출 -> proc_3 호출 순서로 진행되며 값을 채움)
[10, 20, 30, 40]
