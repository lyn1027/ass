1. AL에 있는 ASCII 숫자를 해당하는 2진수 값으로 변환하는 단일 명령어를 작성하세요. 만약 AL이 이미 2진수 값(00h ~ 09h)을 가지고 있다면 변경하지 않고 그대로 둡니다.
[(ASCII '0'은 30h, '9'는 39h이므로 상위 4비트만 제거하면 됨)
and al, 0Fh]

2. 32비트 메모리 오퍼랜드의 패리티(parity)를 계산하는 명령어들을 작성하세요. 힌트: 이 섹션 앞부분에 나온 공식(B0 XOR B1 XOR B2 XOR B3)을 사용하세요.
[
mov al, BYTE PTR [operand]
xor al, BYTE PTR [operand+1]
xor al, BYTE PTR [operand+2]
xor al, BYTE PTR [operand+3]
; 결과에 따라 Parity Flag(PF)가 설정됨
]

3. SetX와 SetY라는 두 개의 비트맵 집합이 주어졌을 때, SetX에는 속하지만 SetY에는 속하지 않는 멤버들을 나타내는 비트 문자열을 EAX에 생성하는 명령어 시퀀스를 작성하세요.
[(논리: X AND (NOT Y))
mov eax, SetX
mov ebx, SetY
not ebx
and eax, ebx
]

4. 부호 없는(unsigned) 정수 DX가 정수 CX보다 작거나 같을 때 레이블 L1으로 점프하는 명령어를 작성하세요.
[
cmp dx, cx
jbe L1
]

5. 부호 있는(signed) 정수 AX가 정수 CX보다 클 때 레이블 L2로 점프하는 명령어를 작성하세요.
[
cmp ax, cx
jg L2
]

-----------------------------------------------------------

6.11 프로그래밍 연습문제 (Programming Exercises)

6. 먼저 AL의 비트 0과 1을 클리어(0으로 설정)하는 명령어를 작성하세요. 그 후, 목적지 오퍼랜드(AL)가 0과 같으면 L3로 점프하고, 그렇지 않으면 L4로 점프해야 합니다.
[
and al, 11111100b  ; 또는 and al, 0FCh
jz L3              ; Zero flag가 1이면(결과가 0이면) 점프
jmp L4             ; 아니면 L4로 점프
]

7. 다음 의사코드(pseudocode)를 어셈블리 언어로 구현하세요. 단락 평가(short-circuit evaluation)를 사용하고 val1과 X는 32비트 변수라고 가정합니다.
   if( val1 > ecx ) AND ( ecx > edx )
     X = 1
   else
     X = 2;
[
    mov eax, val1
    cmp eax, ecx
    jng L_Else      ; val1 <= ecx 이면 Else로 (AND 실패)
    
    cmp ecx, edx
    jng L_Else      ; ecx <= edx 이면 Else로 (AND 실패)
    
    mov X, 1        ; 두 조건 모두 만족 시
    jmp L_End

L_Else:
    mov X, 2
L_End:
]

8. 다음 의사코드를 어셈블리 언어로 구현하세요. 단락 평가를 사용하고 X는 32비트 변수라고 가정합니다.
   if( ebx > ecx ) OR ( ebx > val1 )
     X = 1
   else
     X = 2
[
    cmp ebx, ecx
    jg L_Then       ; ebx > ecx 이면 바로 True (OR 성공)
    
    cmp ebx, val1
    jg L_Then       ; ebx > val1 이면 바로 True (OR 성공)
    
    mov X, 2        ; 둘 다 아니면 Else
    jmp L_End

L_Then:
    mov X, 1
L_End:
]

9. 다음 의사코드를 어셈블리 언어로 구현하세요. 단락 평가를 사용하고 X는 32비트 변수라고 가정합니다.
   if( ebx > ecx AND ebx > edx ) OR ( edx > eax )
     X = 1
   else
     X = 2
[
    ; 첫 번째 그룹 (AND 조건) 확인
    cmp ebx, ecx
    jle Check_Or    ; 첫 조건 실패시 OR의 두 번째 항 체크로 이동
    cmp ebx, edx
    jg L_Then       ; AND 조건 둘 다 만족하면 True

Check_Or:
    ; 두 번째 그룹 (OR 조건) 확인
    cmp edx, eax
    jg L_Then       ; edx > eax 이면 True

L_Else:
    mov X, 2
    jmp L_End

L_Then:
    mov X, 1
L_End:
]

10. 다음 의사코드를 어셈블리 언어로 구현하세요. 단락 평가를 사용하고 A, B, N은 32비트 부호 있는 정수라고 가정합니다.
    while N > 0
      if N != 3 AND ( N < A OR N > B )
        N = N - 2
      else
        N = N - 1
    end while
[
L_While:
    cmp N, 0
    jle L_EndWhile       ; N <= 0 이면 루프 종료

    ; IF 조건 시작
    cmp N, 3
    je L_Else            ; N == 3 이면 AND 조건 실패 -> Else로

    ; (OR 조건 블록)
    mov eax, N
    cmp eax, A
    jl L_Then            ; N < A 이면 True -> Then으로
    cmp eax, B
    jg L_Then            ; N > B 이면 True -> Then으로
    jmp L_Else           ; 둘 다 아니면 Else로

L_Then:
    sub N, 2
    jmp L_While          ; 루프 처음으로

L_Else:
    dec N
    jmp L_While          ; 루프 처음으로

L_EndWhile:
]
