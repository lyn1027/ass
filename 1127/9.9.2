1. 32비트 모드에서의 베이스-인덱스 피연산자(base-index operand)의 예를 하나 보여주세요.
[ mov eax, [ebx + esi] ]

2. 32비트 모드에서의 베이스-인덱스-변위 피연산자(base-index-displacement operand)의 예를 하나 보여주세요.
[ mov eax, array[ebx + esi]  또는  mov eax, [ebx + esi + 10] ]

3. 3개의 논리적 행(row)과 4개의 논리적 열(column)을 가진 더블워드(doubleword, 4바이트) 2차원 배열이 있다고 가정해 봅시다. ESI와 EDI를 사용하여 2번째 행(Row 1)의 3번째 열(Col 2) 주소를 지정하는 표현식을 작성하세요. (행과 열 번호는 0부터 시작합니다.)
[ (ESI * 16) + (EDI * 4) ]

4. sourcew와 targetw라는 이름의 두 16비트 값 배열을 비교하는 CMPSW 사용 명령어를 작성하세요.
[
    cld                     ; 방향 플래그 클리어 (정방향)
    mov esi, OFFSET sourcew ; 소스 주소
    mov edi, OFFSET targetw ; 타겟 주소
    mov ecx, LENGTHOF sourcew ; 길이 설정
    repe cmpsw              ; 같을 동안 반복해서 워드 비교
]

5. wordArray라는 이름의 배열에서 16비트 값 0100h를 스캔(검색)하고, 일치하는 요소의 오프셋(메모리 주소)을 EAX 레지스터로 복사하는 SCASW 사용 명령어를 작성하세요.
[
    cld
    mov ax, 0100h           ; 찾을 값
    mov edi, OFFSET wordArray
    mov ecx, LENGTHOF wordArray
    repne scasw             ; 같지 않을 동안 반복 (찾으면 중단)
    jnz quit                ; 못 찾았으면 점프
    sub edi, 2              ; SCASW가 매칭 후 2바이트 이동하므로 되돌림
    mov eax, edi            ; 오프셋을 EAX로 복사
    quit:
]

6. Str_compare 프로시저를 사용하여 두 입력 문자열 중 더 큰 것을 판별하고, 이를 콘솔 창에 출력하는 일련의 명령어를 작성하세요.
[
    INVOKE Str_compare, ADDR string1, ADDR string2
    ja  str1_larger         ; string1이 더 크면 점프
    jb  str2_larger         ; string2가 더 크면 점프
    ; 같다면 처리할 내용 (생략 가능)
    jmp quit
str1_larger:
    mov edx, OFFSET string1
    call WriteString
    jmp quit
str2_larger:
    mov edx, OFFSET string2
    call WriteString
quit:
]

7. Str_trim 프로시저를 호출하여 문자열 끝에 있는 모든 "@" 문자를 제거하는 방법을 보여주세요.
[ INVOKE Str_trim, ADDR myString, '@' ]

8. Irvine32 라이브러리의 Str_ucase 프로시저를 수정하여 모든 문자를 소문자로 변경하도록 하는 방법을 보여주세요.
[
    ; Str_ucase의 내부 로직 수정 예시
    cmp al, 'A'
    jb  next_char
    cmp al, 'Z'
    ja  next_char
    or  al, 00100000b       ; 또는 add al, 32 (대문자를 소문자로 변환)
    mov [esi], al
next_char:
]

9. Str_trim 프로시저의 64비트 버전을 만드세요.
[ 
Str_trim64 PROC USES rax rcx rdi,
    pString:PTR BYTE,       ; 문자열 포인터 (RCX)
    charToTrim:BYTE         ; 제거할 문자 (DL)
    ; (구현부는 32비트와 유사하되 레지스터를 64비트로 사용: RDI, RCX 등)
    ; 문자열 길이 계산 후 끝에서부터 스캔하며 charToTrim과 비교
    ret
Str_trim64 ENDP
]

10. 64비트 모드에서의 베이스-인덱스 피연산자(base-index operand)의 예를 하나 보여주세요.
[ mov rax, [rbx + rsi] ]

11. EBX에는 myArray라는 이름의 32비트 정수 2차원 배열의 행 인덱스가 들어 있고, EDI에는 열 인덱스가 들어 있다고 가정할 때, 해당 배열 요소의 내용을 EAX 레지스터로 이동시키는 단일 문장(single statement)을 작성하세요.
[ mov eax, myArray[ebx][edi*4] ]

12. RBX에는 myArray라는 이름의 64비트 정수 2차원 배열의 행 인덱스가 들어 있고, RDI에는 열 인덱스가 들어 있다고 가정할 때, 해당 배열 요소의 내용을 RAX 레지스터로 이동시키는 단일 문장을 작성하세요.
[ mov rax, myArray[rbx][rdi*8] ]
