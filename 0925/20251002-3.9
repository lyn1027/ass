1. 세 가지 다른 명령어 니모닉(instruction mnemonics)의 예를 드세요.
[MOV (데이터 이동), ADD (덧셈), SUB (뺄셈)]

2. 호출 규약(calling convention)은 무엇이며, 어셈블리 언어 선언에서 어떻게 사용되나요?
[호출 규약은 함수(프로시저)를 호출할 때 인자를 전달하고, 스택을 정리하며, 반환 값을 처리하는 방법에 대한 규칙입니다. 어셈블리에서는 PROC 지시어와 함께 STDCALL이나 C 같은 키워드를 사용하여 어떤 규약을 따를지 명시합니다.]

3. 프로그램에서 스택(stack)은 어떻게 사용되나요?
[스택은 LIFO(Last-In, First-Out) 구조의 메모리 영역으로, 함수 호출 시 복귀 주소 저장, 매개변수 전달, 지역 변수 할당 등에 사용됩니다.]

4. '어셈블러 언어(assembler language)'라는 용어가 왜 정확하지 않은지 설명하세요.
[언어의 정확한 명칭은 '어셈블리 언어(assembly language)'이고, '어셈블러(assembler)'는 이 언어를 기계어로 번역하는 프로그램을 가리키기 때문입니다. 둘을 혼용하는 것은 언어와 번역기를 혼동하는 것입니다.]

5. 빅 엔디안(big endian)과 리틀 엔디안(little endian)의 차이점을 설명하세요. 또한, 웹에서 이 용어의 기원을 찾아보세요.
[차이점: 메모리에 여러 바이트의 데이터를 저장하는 순서를 의미합니다. 빅 엔디안은 가장 중요한 바이트(MSB)를 가장 낮은 주소에 저장하고, 리틀 엔디안은 가장 덜 중요한 바이트(LSB)를 가장 낮은 주소에 저장합니다. 기원: 이 용어는 조너선 스위프트의 소설 '걸리버 여행기'에서 유래했습니다. 달걀을 깰 때 뭉툭한 끝(big-end)부터 깨는 사람들과 뾰족한 끝(little-end)부터 깨는 사람들 사이의 논쟁에서 비롯되었습니다.]

6. 코드에서 정수 리터럴(integer literal) 대신 심볼릭 상수(symbolic constant)를 사용하는 이유는 무엇인가요?
[코드의 가독성과 유지보수성을 높이기 위해서입니다. 예를 들어 MAX_USERS = 100으로 정의하면, 숫자 100보다 MAX_USERS가 의미를 파악하기 쉽고, 나중에 값을 변경해야 할 때 정의된 한 곳만 수정하면 됩니다.]

7. 소스 파일(source file)은 리스팅 파일(listing file)과 어떻게 다른가요?
[소스 파일(.asm)은 프로그래머가 작성한 어셈블리 코드 원본 파일입니다. 리스팅 파일(.lst)은 어셈블러가 소스 파일을 번역하면서 생성하는 파일로, 원본 코드와 함께 각 명령어가 번역된 기계어 및 메모리 주소가 포함됩니다.]

8. 데이터 레이블(data label)과 코드 레이블(code label)은 어떻게 다른가요?
[데이터 레이블은 변수처럼 데이터가 저장된 메모리 위치를 가리키는 이름이며, 콜론(:)으로 끝나지 않습니다. 코드 레이블은 JMP나 CALL 명령어의 목적지가 되는 코드 상의 위치를 가리키며, 반드시 콜론(:)으로 끝나야 합니다.]

9. 식별자(identifier)는 숫자로 시작할 수 없습니다. [참]

10. 16진수 리터럴(hexadecimal literal)은 0x3A와 같이 쓸 수 있습니다. [거짓]

11. 어셈블리 언어 지시어(directives)는 런타임(runtime)에 실행됩니다. [거짓]

12. 어셈블리 언어 지시어는 대문자와 소문자를 어떤 조합으로든 쓸 수 있습니다. [참]

13. 어셈블리 언어 명령어(instruction)의 네 가지 기본 부분을 나열하세요.
[레이블(Label), 니모닉(Mnemonic), 오퍼랜드(Operand), 주석(Comment)]

14. MOV는 명령어 니모닉의 한 예입니다. [참]

15. 코드 레이블 뒤에는 콜론(:)이 오지만, 데이터 레이블은 콜론으로 끝나지 않습니다. [참]

16. 블록 주석(block comment)의 예를 보여주세요.
[ COMMENT 지시어를 사용하여 특정 문자로 감싸진 블록 전체를 주석 처리할 수 있습니다.]
{ COMMENT !
  이 부분은 블록 주석입니다.
  여러 줄에 걸쳐 작성할 수 있습니다.
! }

17. 변수(variables)에 접근하는 명령어를 작성할 때 숫자 주소(numeric addresses)를 사용하는 것이 좋지 않은 이유는 무엇인가요?
[코드가 메모리의 다른 위치로 로드될 경우 하드코딩된 숫자 주소는 더 이상 유효하지 않게 되기 때문입니다. 이를 재배치(relocatable)가 불가능하다고 합니다. 레이블을 사용하면 링커가 올바른 주소를 자동으로 계산해 줍니다.]

18. ExitProcess 프로시저(procedure)에는 어떤 유형의 인자(argument)가 전달되어야 하나요?
[프로그램의 종료 코드를 나타내는 32비트 정수]

19. 어떤 지시어가 프로시저의 끝을 표시하나요? [ENDP]

20. 32비트 모드에서, END 지시어의 식별자(identifier)는 무엇을 의미하나요?
[프로그램의 시작점(entry point), 즉 실행이 시작될 코드 레이블을 지정합니다.]

21. PROTO 지시어의 목적은 무엇인가요?
[외부에 있거나 아직 정의되지 않은 프로시저의 원형(prototype)을 선언하여, 해당 프로시저를 호출할 때 어셈블러가 인자의 개수와 타입을 검사할 수 있도록 합니다.]

22. 목적 파일(Object file)은 링커(Linker)에 의해 생성됩니다. [거짓]

23. 리스팅 파일(Listing file)은 어셈블러(Assembler)에 의해 생성됩니다. [참]

24. 링크 라이브러리(link library)는 실행 파일(Executable file)을 생성하기 직전에 프로그램에 추가됩니다. [참]

25. 어떤 데이터 지시어가 32비트 부호 있는 정수 변수(signed integer variable)를 생성하나요? [SDWORD]

26. 어떤 데이터 지시어가 16비트 부호 있는 정수 변수를 생성하나요? [SWORD]

27. 어떤 데이터 지시어가 64비트 부호 없는 정수 변수(unsigned integer variable)를 생성하나요? [QWORD]

28. 어떤 데이터 지시어가 8비트 부호 없는 정수 변수를 생성하나요? [BYTE]

29. 어떤 데이터 지시어가 10바이트 팩 BCD(packed BCD) 변수를 생성하나요? [TBYTE]
