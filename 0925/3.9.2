1. 정수 25를 10진수, 2진수, 8진수, 16진수 형식으로 나타내는 네 개의 심볼릭 상수(symbolic constants)를 정의하세요.
[
valDec = 25
valBin = 11001b
valOct = 31q
valHex = 19h
]

2. 프로그램이 여러 개의 코드 세그먼트(code segments)와 데이터 세그먼트(data segments)를 가질 수 있는지 시행착오를 통해 확인해보세요.
[예, 가능합니다. (프로그램 내에서 .data와 .code 지시어를 여러 번 사용하거나 다른 이름을 부여하여 여러 세그먼트를 정의할 수 있습니다.)]

3. 메모리에 빅 엔디안(big endian) 형식으로 저장되는 더블워드(doubleword)에 대한 데이터 정의를 작성하세요. (예: 값 12345678h를 저장할 때)
[val BYTE 12h, 34h, 56h, 78h]
(설명: x86은 기본적으로 리틀 엔디안이므로, 빅 엔디안으로 저장하려면 바이트 단위로 직접 순서를 지정해야 합니다.)

4. DWORD 타입 변수를 선언하고 음수 값을 할당할 수 있는지 확인해보세요. 이것은 어셈블러의 타입 체크(type checking)에 대해 무엇을 말해줍니까?
[
.data
var1 DWORD -10  ; 가능함
]
[어셈블러의 타입 체크가 유연하며, 부호(sign)보다는 데이터의 크기(비트 수)에 더 중점을 둔다는 것을 의미합니다. -10은 2의 보수 형태인 FFFFFFF6h로 저장됩니다.]

5. (1) EAX 레지스터에 5를 더하는 명령어와 (2) EDX 레지스터에 5를 더하는 명령어, 두 가지 명령어를 포함하는 프로그램을 작성하세요. 리스팅 파일을 생성하여 어셈블러가 생성한 기계어 코드를 검사해보세요. 두 명령어 사이에 차이점이 있다면 무엇입니까?
[
add eax, 5
add edx, 5
]
[차이점: 기계어의 오퍼코드(opcode)가 다릅니다. EAX에 더하는 명령은 최적화되어 더 짧은 코드가 생성되거나 특정 오퍼코드를 사용하지만, EDX에 더하는 명령은 일반적인 레지스터 덧셈 오퍼코드를 사용합니다.]

6. 숫자 456789ABh가 주어졌을 때, 리틀 엔디안(little-endian) 순서로 바이트 값들을 나열하세요. [ABh, 89h, 67h, 45h]

7. 초기화되지 않은 120개의 부호 없는 더블워드(unsigned doubleword) 값의 배열을 선언하세요. [myArray DWORD 120 DUP(?)]

8. 바이트 배열을 선언하고 알파벳의 처음 5글자로 초기화하세요. [myBytes BYTE 'A', 'B', 'C', 'D', 'E']

9. 32비트 부호 있는 정수 변수를 선언하고 가능한 가장 작은 음수 10진수 값으로 초기화하세요. [minVal SDWORD -2147483648]

10. 세 개의 초기값(initializers)을 사용하는 wArray라는 이름의 부호 없는 16비트 정수 변수(배열)를 선언하세요. [wArray WORD 1000h, 2000h, 3000h]

11. 가장 좋아하는 색상의 이름을 포함하는 문자열 변수를 선언하세요. 널(null)로 끝나는 문자열로 초기화해야 합니다. [myColor BYTE "Blue", 0]

12. dArray라는 이름의 초기화되지 않은 50개의 부호 있는 더블워드(signed doublewords) 배열을 선언하세요. [dArray SDWORD 50 DUP(?)]

13. "TEST"라는 단어가 500번 반복되는 내용을 담은 문자열 변수를 선언하세요. [myString BYTE 500 DUP("TEST")]

14. bArray라는 이름의 20바이트 부호 없는 배열을 선언하고 모든 요소를 0으로 초기화하세요. [bArray BYTE 20 DUP(0)]

15. 다음 더블워드 변수에 대해 메모리에 저장되는 개별 바이트의 순서(가장 낮은 주소에서 가장 높은 주소 순)를 보여주세요.
    val1 DWORD 87654321h
[21h, 43h, 65h, 87h]
