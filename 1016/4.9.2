1. `three`라는 이름의 더블워드(doubleword) 변수에서 상위 워드와 하위 워드를 서로 교환하는 MOV 명령어 시퀀스를 작성하세요.
[
mov ax, WORD PTR three
mov bx, WORD PTR three+2
mov WORD PTR three, bx
mov WORD PTR three+2, ax
]

2. XCHG 명령어를 세 번 이하로 사용하여, 4개의 8비트 레지스터에 있는 값의 순서를 A, B, C, D에서 B, C, D, A 순서로 재배치하세요.
[
xchg al, bl
xchg bl, cl
xchg cl, dl
]

3. 전송된 메시지에는 1 비트의 개수가 짝수가 되도록 만드는 패리티 비트가 포함되는 경우가 많습니다. AL 레지스터에 01110101 값을 가진 메시지 바이트가 있다고 가정할 때, 산술 명령어와 패리티 플래그(Parity flag)를 사용하여 이 메시지 바이트가 짝수 패리티인지 홀수 패리티인지 판별하는 방법을 보여주세요.
[
add al, 0
; 실행 후 패리티 플래그(PF)를 확인합니다.
; 01110101에는 1이 5개(홀수) 있으므로 패리티 플래그는 0 (PE=False/PO=True)이 됩니다.
]

4. 바이트 오퍼랜드를 사용하여 두 개의 음수 정수를 더하고 오버플로우 플래그(Overflow flag)가 설정되도록 하는 코드를 작성하세요.
[
mov al, -100
add al, -50
; 결과가 -150이 되어 부호 있는 8비트 범위(-128~+127)를 벗어나므로 OF=1
]

5. 덧셈을 사용하여 제로 플래그(Zero flag)와 캐리 플래그(Carry flag)를 동시에 설정하는 두 개의 명령어 시퀀스를 작성하세요.
[
mov al, 0FFh
add al, 1
; 결과는 100h가 되지만 AL에는 00h가 저장됨(ZF=1), 범위 초과 발생(CF=1)
]

6. 뺄셈을 사용하여 캐리 플래그를 설정하는 두 개의 명령어 시퀀스를 작성하세요.
[
mov al, 1
sub al, 2
; 작은 수에서 큰 수를 뺐으므로 빌림(borrow) 발생하여 CF=1
]

7. 어셈블리 언어로 다음 산술 식을 구현하세요: EAX = -val2 + 7 - val3 + val1.
[
mov eax, val2
neg eax
add eax, 7
sub eax, val3
add eax, val1
]

8. 인덱스 주소 지정(indexed addressing)과 스케일 팩터(scale factor)를 사용하여 더블워드 배열을 반복하고 요소들의 합을 계산하는 루프를 작성하세요.
[
; ESI=인덱스, ECX=카운터, EAX=합계 가정
L1:
    add eax, array[esi*4]
    inc esi
    loop L1
]

9. 어셈블리 언어로 다음 식을 구현하세요: AX = (val2 + BX) - val4.
[
mov ax, val2
add ax, bx
sub ax, val4
]

10. 캐리 플래그와 오버플로우 플래그를 동시에 설정하는 두 개의 명령어 시퀀스를 작성하세요.
[
mov al, 80h    ; -128 (부호 있음), 128 (부호 없음)
add al, 80h    ; -128 + (-128) = -256 (OF=1), 128 + 128 = 256 (CF=1)
]

11. INC와 DEC 명령어 실행 후, 부호 없는 오버플로우(unsigned overflow)를 나타내기 위해 제로 플래그가 어떻게 사용될 수 있는지 보여주는 명령어 시퀀스를 작성하세요.
[
mov al, 0FFh
inc al
jz OverflowHandler
; INC는 CF를 변경하지 않지만, FFh에서 00h로 랩어라운드될 때 ZF가 1이 됩니다.
]

< 다음 데이터 정의를 사용하세요 12번 ~ 18번 >
.data
myBytes  BYTE 10h, 20h, 30h, 40h
myWords  WORD 3 DUP(?), 2000h
myString BYTE "ABCDE"

12. 주어진 데이터 정의에서 myBytes가 짝수 주소에 정렬되도록 하는 지시어를 삽입하세요.
[ALIGN 2] (myBytes 정의 바로 윗줄에 삽입)

13. 다음 각 명령어가 실행된 후 EAX의 값은 무엇입니까?
    a. mov eax, TYPE myBytes
    b. mov eax, LENGTHOF myBytes
    c. mov eax, SIZEOF myBytes
    d. mov eax, TYPE myWords
    e. mov eax, LENGTHOF myWords
    f. mov eax, SIZEOF myWords
    g. mov eax, SIZEOF myString
[a. 1, b. 4, c. 4, d. 2, e. 4, f. 8, g. 5]

14. myBytes의 처음 2바이트를 DX 레지스터로 이동시키는 단일 명령어를 작성하세요. 결과 값은 2010h가 되어야 합니다.
[mov dx, WORD PTR myBytes]

15. myWords의 두 번째 바이트를 AL 레지스터로 이동시키는 명령어를 작성하세요.
[mov al, BYTE PTR myWords+1]

16. myBytes의 4바이트 전체를 EAX 레지스터로 이동시키는 명령어를 작성하세요.
[mov eax, DWORD PTR myBytes]

17. myWords가 32비트 레지스터로 직접 이동될 수 있도록 허용하는 LABEL 지시어를 주어진 데이터에 삽입하세요.
[myWordsDouble LABEL DWORD] (myWords 정의 바로 윗줄에 삽입)

18. myBytes가 16비트 레지스터로 직접 이동될 수 있도록 허용하는 LABEL 지시어를 주어진 데이터에 삽입하세요.
[myBytesWord LABEL WORD] (myBytes 정의 바로 윗줄에 삽입)
